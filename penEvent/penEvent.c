#if 0
USB 输入设备
Connection Status	Device connected
Current Configuration	1
Speed	Full
Device Address	4
Number Of Open Pipes	1
Device Descriptor TABLET
Offset	Field	Size	Value	Description
0 	bLength 	1 	12h 	
1 	bDescriptorType 	1 	01h 	Device
2 	bcdUSB 	2 	0200h 	USB Spec 2.0
4 	bDeviceClass 	1 	00h 	Class info in Ifc Descriptors
5 	bDeviceSubClass 	1 	00h 	
6 	bDeviceProtocol 	1 	00h 	
7 	bMaxPacketSize0 	1 	20h 	32 bytes
8 	idVendor 	2 	0ED1h 	WinMaxGroup
10 	idProduct 	2 	782Ch 	
12 	bcdDevice 	2 	0242h 	2.42
14 	iManufacturer 	1 	01h 	"AHA"
15 	iProduct 	1 	02h 	"TABLET"
16 	iSerialNumber 	1 	00h 	
17 	bNumConfigurations 	1 	01h 	
Configuration Descriptor 1 Bus Powered, 100 mA
Offset	Field	Size	Value	Description
0 	bLength 	1 	09h 	
1 	bDescriptorType 	1 	02h 	Configuration
2 	wTotalLength 	2 	0022h 	
4 	bNumInterfaces 	1 	01h 	
5 	bConfigurationValue 	1 	01h 	
6 	iConfiguration 	1 	00h 	
7 	bmAttributes 	1 	A0h 	Bus Powered, Remote Wakeup
	4..0: Reserved 		...00000  	
	5: Remote Wakeup 		..1.....  	Yes
	6: Self Powered 		.0......  	No, Bus Powered
	7: Reserved (set to one)
(bus-powered for 1.0) 		1.......  	
8 	bMaxPower 	1 	32h 	100 mA
Interface Descriptor 0/0 HID, 1 Endpoint
Offset	Field	Size	Value	Description
0 	bLength 	1 	09h 	
1 	bDescriptorType 	1 	04h 	Interface
2 	bInterfaceNumber 	1 	00h 	
3 	bAlternateSetting 	1 	00h 	
4 	bNumEndpoints 	1 	01h 	
5 	bInterfaceClass 	1 	03h 	HID
6 	bInterfaceSubClass 	1 	01h 	Boot Interface
7 	bInterfaceProtocol 	1 	02h 	Mouse
8 	iInterface 	1 	00h 	
HID Descriptor
Offset	Field	Size	Value	Description
0 	bLength 	1 	09h 	
1 	bDescriptorType 	1 	21h 	HID
2 	bcdHID 	2 	0111h 	1.11
4 	bCountryCode 	1 	00h 	
5 	bNumDescriptors 	1 	01h 	
6 	bDescriptorType 	1 	22h 	Report
7 	wDescriptorLength 	2 	0084h 	132 bytes
Endpoint Descriptor 81 1 In, Interrupt, 5 ms
Offset	Field	Size	Value	Description
0 	bLength 	1 	07h 	
1 	bDescriptorType 	1 	05h 	Endpoint
2 	bEndpointAddress 	1 	81h 	1 In
3 	bmAttributes 	1 	03h 	Interrupt
	1..0: Transfer Type 		......11  	Interrupt
	7..2: Reserved 		000000..  	
4 	wMaxPacketSize 	2 	0008h 	8 bytes
6 	bInterval 	1 	05h 	5 ms
Interface 0 HID Report Descriptor Pen
Item Tag (Value) 	Raw Data
Usage Page (Digitizer) 	05 0D 
Usage (Pen) 	09 02 
Collection (Application) 	A1 01 
    Report ID (1) 	85 01 
    Usage (Stylus) 	09 20 
    Collection (Physical) 	A1 00 
        Usage (Tip Switch) 	09 42 
        Usage (Barrel Switch) 	09 44 
        Usage (Eraser) 	09 45 
        Usage (Invert) 	09 3C 
        Usage (In Range) 	09 32 
        Logical Minimum (0) 	15 00 
        Logical Maximum (1) 	25 01 
        Report Size (1) 	75 01 
        Report Count (5) 	95 05 
        Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit) 	81 02 
        Report Count (3) 	95 03 
        Input (Cnst,Var,Abs,NWrp,Lin,Pref,NNul,Bit) 	81 03 
        Usage Page (Generic Desktop) 	05 01 
        Usage (X) 	09 30 
        Report Size (16) 	75 10 
        Report Count (1) 	95 01 
        Push 	A4 
        Unit Exponent (-3) 	55 0D 
        Unit (SI Lin: Length (cm)) 	65 11 
        Logical Minimum (0) 	15 00 
        Logical Maximum (27136) 	26 00 6A 
        Physical Minimum (0) 	35 00 
        Physical Maximum (27136) 	46 00 6A 
        Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit) 	81 02 
        Usage (Y) 	09 31 
        Logical Minimum (0) 	15 00 
        Logical Maximum (15360) 	26 00 3C 
        Physical Minimum (0) 	35 00 
        Physical Maximum (15360) 	46 00 3C 
        Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit) 	81 02 
        Usage Page (Digitizer) 	05 0D 
        Usage (Tip Pressure) 	09 30 
        Logical Minimum (0) 	15 00 
        Logical Maximum (1023) 	26 FF 03 
        Physical Minimum (0) 	35 00 
        Physical Maximum (1023) 	46 FF 03 
        Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit) 	81 02 
    End Collection 	C0 
End Collection 	C0 
Usage Page (Vendor-Defined 1) 	06 00 FF 
Usage (Vendor-Defined 1) 	09 01 
Collection (Application) 	A1 01 
    Report ID (2) 	85 02 
    Usage (Vendor-Defined 32) 	09 20 
    Collection (Physical) 	A1 00 
        Usage (Vendor-Defined 63) 	09 3F 
        Logical Minimum (0) 	15 00 
        Logical Maximum (-1) 	25 FF 
        Report Size (8) 	75 08 
        Report Count (7) 	95 07 
        Input (Data,Var,Abs,NWrp,Lin,Pref,NNul,Bit) 	81 02 
        Usage (Vendor-Defined 64) 	09 40 
        Report Size (8) 	75 08 
        Report Count (3) 	95 03 
        Logical Minimum (0) 	15 00 
        Logical Maximum (-1) 	25 FF 
        Feature (Data,Var,Abs,NWrp,Lin,Pref,NNul,NVol,Bit) 	B1 02 
    End Collection 	C0 
End Collection 	C0 

This report was generated by USBlyzer

#endif
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <errno.h>
#include <paths.h>
#include <termios.h>
#include <sysexits.h>
#include <sys/param.h>
#include <sys/select.h>
#include <sys/time.h>
#include <signal.h>

#include <CoreFoundation/CoreFoundation.h>
#include <Carbon/Carbon.h>
#include <CarbonCore/CarbonCore.h>
#include <CoreServices/CoreServices.h>
#include <IOKit/IOKitLib.h>

#include <IOKit/hid/IOHIDLib.h>
#include <IOKit/hidsystem/ev_keymap.h>

#include <IOKit/serial/IOSerialKeys.h>
#include <IOKit/IOBSD.h>

#include <IOKit/usb/IOUSBLib.h>
#include <IOKit/hidsystem/IOHIDShared.h>


#include <CarbonCore/CarbonCore.h>


#include <CoreFoundation/CoreFoundation.h>
#include <Carbon/Carbon.h>


#include <IOKit/IOKitLib.h>

#include <IOKit/hid/IOHIDLib.h>

#include <IOKit/serial/IOSerialKeys.h>
#include <IOKit/IOBSD.h>

#include <IOKit/usb/IOUSBLib.h>
#include <IOKit/hidsystem/IOHIDShared.h>

#if 0
#define HDX_VendorID 0xED1
#define HDX_ProductID 0x782C
#else
//Bus 020 Device 009: ID 0ed1:7805 0ed1 TGT DIGITIZER
#define HDX_VendorID 0xED1
#define HDX_ProductID 0x7805
#endif


//27136 * 15360 * 1023
IOHIDDeviceRef currentDeviceRef=NULL;
uint8_t buffer[32];
void HIDPostAuxKey(const UInt8 auxKeyCode );
void ProcessPenProcess(uint32_t reportID, uint8_t *inReport, CFIndex length);
void printCurrenTime()
{
    time_t timep;
    
    time (&timep);
    fprintf(stderr,"%s ",ctime(&timep));
}
static void theInputReportCallback(void *context, IOReturn inResult, void * inSender, IOHIDReportType inReportType,
								   uint32_t reportID, uint8_t *inReport, CFIndex length);

void theDeviceRemovalCallback (void *context, IOReturn result, void *sender, IOHIDDeviceRef device)
{
	currentDeviceRef=NULL;
	IOHIDDeviceUnscheduleFromRunLoop( device, CFRunLoopGetCurrent( ), kCFRunLoopDefaultMode );
	fprintf(stderr,"Tablet removed!\n");
}


void theDeviceMatchingCallback(void *inContext, IOReturn inResult, void *inSender, IOHIDDeviceRef  inIOHIDDeviceRef)
{
    if (NULL != currentDeviceRef)
        return;
	currentDeviceRef=inIOHIDDeviceRef;

	fprintf(stderr,"Tablet connected!\n");
	IOHIDDeviceScheduleWithRunLoop(inIOHIDDeviceRef, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
	IOHIDDeviceRegisterInputReportCallback(inIOHIDDeviceRef, buffer, 4096, theInputReportCallback, "hund katze maus");
}

static void theInputReportCallback(void *context, IOReturn inResult, void * inSender, IOHIDReportType inReportType,
								   uint32_t reportID, uint8_t *inReport, CFIndex length)
{
	switch (reportID) {
		case 0x01:
            ProcessPenProcess(reportID, inReport, length);
			break;
			
		default:
			break;
	}
	
}

IOHIDManagerRef	ioHidManager;
void ctrlc(int n)
{
    
    if(n == SIGINT)
    {
        if (ioHidManager) {
            IOHIDManagerRegisterDeviceMatchingCallback(ioHidManager, NULL, NULL);
            IOHIDManagerRegisterDeviceRemovalCallback(ioHidManager, NULL,NULL);
            IOHIDManagerUnscheduleFromRunLoop(ioHidManager, CFRunLoopGetCurrent(), kCFRunLoopCommonModes);
            IOHIDManagerClose(ioHidManager, kIOHIDOptionsTypeNone);
            CFRelease(ioHidManager);
            ioHidManager = NULL;
        }
        fprintf(stderr,"Press <Ctrl-C> to quit\n");
        exit(0);
    }
}


int main (int argc, char * argv[]) {
    
    signal(SIGINT, ctrlc);

#if 0//simulat vol_up keycode
    HIDPostAuxKey( NX_KEYTYPE_SOUND_UP );
    return 0;
#endif
    static const unsigned kHDXVendorId = HDX_VendorID;
    static const unsigned kHDXProductId = HDX_ProductID;
    
	ioHidManager = IOHIDManagerCreate(kIOHIDOptionsTypeNone, 0);
	
	CFNumberRef vendorID=CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &kHDXVendorId);
	CFNumberRef productID=CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &kHDXProductId);

	// Create Matching dictionary
	CFMutableDictionaryRef matchingDictionary = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);

	// set entries
	CFDictionarySetValue(matchingDictionary, CFSTR(kIOHIDVendorIDKey), vendorID);
	CFDictionarySetValue(matchingDictionary, CFSTR(kIOHIDProductKey), productID);
	CFRelease(productID);
	CFRelease(vendorID);

	IOHIDManagerSetDeviceMatching(ioHidManager, matchingDictionary);
    CFRelease(matchingDictionary);
	IOReturn ioReturn=IOHIDManagerOpen(ioHidManager,kIOHIDOptionsTypeSeizeDevice);
	
	if (ioReturn==kIOReturnSuccess) {
		IOHIDManagerRegisterDeviceRemovalCallback(ioHidManager, theDeviceRemovalCallback, NULL) ; 
		IOHIDManagerRegisterDeviceMatchingCallback(ioHidManager, theDeviceMatchingCallback,NULL);
		
		IOHIDManagerScheduleWithRunLoop( ioHidManager , CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
		CFRunLoopRun();
	}
    
    //ioReturn=IOHIDManagerClose(ioHidManager , kIOHIDOptionsTypeNone);
    //CFRelease(ioHidManager);
    fprintf(stderr,"why u run here?\n");
    return 0;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////

static io_connect_t get_event_driver(void)
{
    static  mach_port_t sEventDrvrRef = 0;
    mach_port_t masterPort, service, iter;
    kern_return_t    kr;
    
    if (!sEventDrvrRef)
    {
        // Get master device port
        kr = IOMasterPort( bootstrap_port, &masterPort );
        check( KERN_SUCCESS == kr);
        
        kr = IOServiceGetMatchingServices( masterPort, IOServiceMatching( kIOHIDSystemClass ), &iter );
        check( KERN_SUCCESS == kr);
        
        service = IOIteratorNext( iter );
        check( service );
        
        kr = IOServiceOpen( service, mach_task_self(),
                           kIOHIDParamConnectType, &sEventDrvrRef );
        check( KERN_SUCCESS == kr );
        
        IOObjectRelease( service );
        IOObjectRelease( iter );
    }
    return sEventDrvrRef;
}

void HIDPostAuxKey(const UInt8 auxKeyCode )
{
    NXEventData   event;
    kern_return_t kr;
    IOGPoint      loc = { 0, 0 };
    
    // Key press event
    UInt32      evtInfo = auxKeyCode << 16 | NX_KEYDOWN << 8;
    bzero(&event, sizeof(NXEventData));
    event.compound.subType = NX_SUBTYPE_AUX_CONTROL_BUTTONS;
    event.compound.misc.L[0] = evtInfo;
    kr = IOHIDPostEvent( get_event_driver(), NX_SYSDEFINED, loc, &event, kNXEventDataVersion, 0, FALSE );
    check( KERN_SUCCESS == kr );
    
    // Key release event
    evtInfo = auxKeyCode << 16 | NX_KEYUP << 8;
    bzero(&event, sizeof(NXEventData));
    event.compound.subType = NX_SUBTYPE_AUX_CONTROL_BUTTONS;
    event.compound.misc.L[0] = evtInfo;
    kr = IOHIDPostEvent( get_event_driver(), NX_SYSDEFINED, loc, &event, kNXEventDataVersion, 0, FALSE );
    check( KERN_SUCCESS == kr );
}

int getBit(char data, int i) {
    return (data >> i) & 0x01;
}

#if 0
Usage (Tip Switch) 	09 42
Usage (Barrel Switch) 	09 44
Usage (Eraser) 	09 45
Usage (Invert) 	09 3C
Usage (In Range) 	09 32
#endif

typedef struct {
    const char btnName[15];
    bool btnisDown;
    bool btnwasDown;
} btnInfo;

btnInfo PenBtnInfo[5] = {
    {"Tip Switch",false,false},
    {"Barrel Switch",false,false},
    {"Eraser",false,false},
    {"Invert",false,false},
    {"In Range",false,false}
};

typedef struct {
    uint16_t x;
    uint16_t y;
    uint16_t p;
} posInfo;

posInfo PenPosInfo[2] = {
    {0,0,0},
    {0,0,0}
};

void ProcessPenProcess(uint32_t reportID, uint8_t *inReport, CFIndex length)
{
#if 0
    fprintf(stderr,"reportID 0-1-2+3-4+5-6+7 : %x %x %02x %05d %05d %04d ", reportID, (uint8_t)*(inReport), (uint8_t)*(inReport+1),(uint32_t)(inReport[2] | inReport[3] << 8),(uint32_t)(inReport[4] | inReport[5] << 8),(uint32_t)(inReport[6] | inReport[7] << 8));
#endif
    PenPosInfo[0].x = (uint16_t)(inReport[2] | inReport[3] << 8);
    PenPosInfo[0].y = (uint16_t)(inReport[4] | inReport[5] << 8);
    PenPosInfo[0].p = (uint16_t)(inReport[6] | inReport[7] << 8);
    for (int i=0; i < 5; i++)
    {
        PenBtnInfo[i].btnisDown = getBit(inReport[1],i);
        if(PenBtnInfo[i].btnisDown != PenBtnInfo[i].btnwasDown)
        {
            fprintf(stderr,"Button Change: %s %05d %05d %04d %s \n", PenBtnInfo[i].btnisDown?"v":"^",PenPosInfo[0].x,PenPosInfo[0].y, PenPosInfo[0].p, PenBtnInfo[i].btnName);
        }
    }
    
    //save states
    for (int i=0; i < 5; i++)
    {
        PenBtnInfo[i].btnwasDown = PenBtnInfo[i].btnisDown;
    }
    PenPosInfo[1].x = PenPosInfo[0].x;
    PenPosInfo[1].y = PenPosInfo[0].y;
    PenPosInfo[1].p = PenPosInfo[0].p;
    
}